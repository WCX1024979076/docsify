# 计算机图形学复习

### 第一章 绪论

**定义**

计算机图形学是研究通过计算机将数据转换为图形，并在专门的显示设备上显示的原理、方法和技术的学科。

计算机图形学就是应用计算机技术进行图形的生成、处理和输出。

**图形的基本要素**

几何要素，刻画对象的轮廓、形状等。如点，线，多边形，多面体等；

非几何要素，刻画对象的颜色、材质等。如颜色，纹理等。

**图形表示 存储方法**

1. 点阵法

   枚举出图形中所有的点(强调由点<像素>构成），这种表示的图形称为图像。

2. 参数法

   由图形的形状参数(方程或表达式的系数，线段的端点坐标等) + 属性参数(颜色、线型等) )来表示图形，称为图形（graphics），如圆可用半径、圆心坐标和颜色表示

**计算机图形学基本研究内容**

1、图形系统（硬、软、标准化）

2、基本图形生成：如何显示点、线段、多边形及圆等几何图形

3、图形的处理：几何变换（图形动起来）；投影变换（如何显示三维图形）；真实感图形（光照、阴影。。。）

4、物体造型：实体表示；曲线曲面；真实感

### 第二章 计算机图形系统概述

**计算机图形系统**

1. 组成

   1. 硬件与软件示意图

      ![image-20211206223937534](https://pic.tim-wcx.ltd//img/20211206223939.png)

   2. 硬件：输入设备、输出设备、存储设备、图形处理设备

   3. 软件：软件包、应用程序、应用模型

2. 基本功能

   1. 计算：图形处理（如图形变换、光照等）
   2. 存储：远程和本机
   3. 输入：人机交互及数据文件等
   4. 输出：显示器、打印机等
   5. 对话图形：人机交互

**显示设备**

1. 两种设备
   1. 阴极射线管CRT (Cathode Ray Tube)

      特点：亮度高、对比度好、色彩鲜艳

      缺点：体积大，笨重

   2. 平板型显示器：液晶、等离子

      特点：器件薄，适合便携

      缺点：亮度和对比度相对较低、色彩不够鲜艳，价格偏高

2. CRT

   1. 基本原理

      一种真空器件，它利用电磁场产生高速的、经过聚焦的电子束，偏转到屏幕的不同位置，轰击屏幕表面的荧光材料，从而产生可见的图形

   2. 组成

      电子枪、聚焦系统、加速电极、偏转系统、荧光屏

   3. 电子枪
      电灯丝，阴极和控制栅组成

      灯丝：产生热量

      阴极：由灯丝加热发出电子束

      控制栅：加上负电压后，能够控制通过其中小孔的带负电的电子束的强弱。通过调节负电压高低来控制电子数量，即控制荧光屏上相应点的亮度

   4. 电子枪
      电灯丝，阴极和控制栅组成

      灯丝：产生热量

      阴极：由灯丝加热发出电子束

   5. 控制栅

      加上负电压后，能够控制通过其中小孔的带负电的电子束的强弱。通过调节负电压高低来控制电子数量，即控制荧光屏上相应点的亮度

   6. 加速电极 加正的高压电（几万伏） 使电子束高速运动

   7. 偏转系统

      控制电子束，静电场或磁场，产生偏转

      最大偏转角是衡量系统性能的最重要的指标，显示器长短与此有关

   8. 荧光屏
      荧光物质：吸收电子束而发光

      持续发光时间：电子束离开某点后，该点的亮度值衰减到初始值1/10 所需的时间

      刷新(Refresh)：为了让荧光物质保持一个稳定的亮度值

      刷新频率：每秒钟重绘屏幕的次数

      CRT产生稳定图像所需要的最小刷新频率=1秒/荧光物质的持续发光时间

      例：荧光物质的持续发光时间40毫秒，刷新频率就是 1000/40=25Hz

3. 彩色CRT

   1. 射线穿透法

      原理：两层荧光涂层，红色光和绿色光两种发光物质，电子束轰击穿透荧光层的深浅，决定所产生的颜色

      应用：主要用于画线显示器

      特点：优点是成本低；缺点是只能产生有限几种颜色

   2. 影孔板法
      应用：主要用于光栅扫描显示器

      结构：外层玻璃、荧光涂层和影孔板，影孔板被安装在荧光屏的内表面，用于精确定位像素的位置

      工作原理：每个像素处有3个荧光点，呈三角形排列。三支电子枪对应红、绿、蓝三基色。电子枪、影孔板中的一个小孔和荧光点呈一直线；每个小孔与一个像素（即三个荧光点）对应。

      亮度调节：各电子枪发生的电子数目，可控制各色光点亮度

4. 液晶显示器LCD

   在液晶分子两端所加电压的不同，液晶分子的翻转程 度不同，根据液晶角度的不同透过光的偏振性也不同；

   液晶可以被光穿透，并影响光的偏振性；

   液晶的电光效应：当液晶分子的某种排列状态在电场作用下变为另一种排列状态时，液晶的光学性质随之改变。

   液晶显示的机理：通过能阻塞或传递光的液晶材料，传递来自周围的或内部光源的偏振光

   组成：光源、垂直偏光板、玻璃电极、液晶、玻璃电极、水平偏光板

5. 比较

   1. 共同特点

         都是通过单个发光元素（点，像素）来显示图形或文字。
         
      2. 不同点
   
         （1）LCD体积小，厚度薄，重量轻，耗能少，辐射很少。（2）CRT显示亮度高，色彩鲜艳，分辨率高。

**性能指标**

像素(Pixel: Picture Cell)：构成屏幕（图像）的最小元素

分辨率(Resolution)：CRT在水平或竖直方向单位长度上能识别的最大像素个数，单位通常为dpi（dots per inch)

分辨率越高显示的图形就越精细

**显示系统**

1. 主要组成

   显示设备：显示器

   视频控制器：控制显示设备（有的含图形加速处理器），通过访问帧缓存来刷新屏幕

   显示缓冲存储器（帧缓存）：可以在内存或显示控制器中

   ![image-20211206225420561](https://pic.tim-wcx.ltd//img/20211206225420.png)

   <img src="https://pic.tim-wcx.ltd//img/20211206225721.png" alt="image-20211206225720957" style="zoom: 67%;" />

2. 显示系统

   1. 随机扫描（random scan）：电子束可以任意移动。画线设备

       特点：电子束可随意移动，只扫描荧屏上要显示的部分像素、对应的显示器为画线设备

       逻辑部件：刷新存储器(Refreshing Buffer)、显示处理器（DPU: Display Processing Unit、CRT

   2. 光栅扫描（raster scan）：电子束按固定扫描线和次序进行。画点设备

       1. 基本概念

          基本原理：电子束按固定的扫描线和扫描顺序从左到右、自上而下进行扫描。

          基本概念：扫描线：一条水平线 帧（frame）：1次扫描生成的图像

          水平回扫期：水平线间的回扫期 垂直回扫期：帧间的回扫期

       2. 组成
          帧缓冲存储器（Frame Buffer)--帧缓存

          视频控制器（Video Controller)

          显示处理器（Display Processor）

          显示器：CRT、液晶

       3. 帧缓存

          作用：存储屏幕上像素的颜色值

          帧缓存中单元数目与显示器上像素的数目相同，单元与像素一一对应，各单元的数值决定了其对应像素的颜色。

          显示颜色的种类与帧缓存中每个单元的位数有关。如：黑白显示系统的帧缓冲器的每个单元只需一位。

          帧缓存容量：分辨率M\*N、颜色个数K 与缓存大小V 的关系 $V \geq M*N* \lceil log_2 K \rceil $

          目前有的PC机的显存容量达512M以上，有必要？

          原因：显存还包括深度缓存、纹理内存等

       4. 颜色模型 三基色

          RGB三基色：面向硬件设备（摄像机、扫描仪和投影仪等）

          CMY三基色：三补色： 蓝绿(C, cyan)，品红(M, magenta)，黄(Y, yellow) 用于彩色打印

          CMY与RGB关系：R=1-C、G=1-M、B=1-Y

       5. 视频控制器

          <img src="https://pic.tim-wcx.ltd//img/20211206230352.png" alt="image-20211206230351943" style="zoom:50%;" />

       6. 显示处理器

          作用：代替CPU完成部分图形处理功能，扫描转换、几何变换、裁剪、光栅操作、纹理映射等等

          具有专用显示处理器的光栅显示系统的结构

          图形加速卡 = 视频控制器 + 显存 + 显示处理器

          显卡=显示处理器的专用存储器+帧缓冲器+视频控制器+显示处理器

          ![image-20211206230818600](https://pic.tim-wcx.ltd//img/20211206230818.png)

       7. 特点
          优点：成本低、易于绘制填充图形、色彩丰富、刷新频率一定、与图形的复杂程度无关、易于修改图形

          缺点：需要扫描转换，复杂图形计算量大、会产生混淆（走样）

**软件系统**

1. 第一层次：面向硬件系统

  解决图形设备与计算机的通讯接口等问题，称为设备驱动程序

  设备驱动程序现在已被作为操作系统一部分，由操作系统或设备硬件厂商开发； 

2. 第二层次：建立在驱动程序之上

  完成图元的生成、设备的管理等功能

  这个层次上的图形支撑软件已经标准化，如GKS、PHIGS、CGI等； 

3. 第三层次：面向用户

  主要任务是建立图形数据结构，定义、修改和输出图形

  具有较强的交互功能，使用方便，容易阅读，便于维护和移植

  OpenGL、Direct3D属于这一层次

### 第三章  基本光栅图形生成技术

**光栅图形学**

1. 图元的生成

   是指完成图元的参数表示形式到点阵表示形式的转换。通常也称扫描转换图元(Scan Converter) 

   参数表示形式由不同种类图形的性质决定，点阵表示形式是光栅显示系统刷新时所需的表示形式。

2. openGL相关函数

   ```c
   //初始化颜色
   glClearColor(0,1,0,1); 
   //清除帧缓存，并将每个像素对应单元赋为背景颜色值
   glClear( GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT ); 
   //表示结束绘图命令，使用单缓存时必须要。双缓冲时可以不要
   glFinish();
   //双缓存时使用。交换缓存命令，表示当前显示帧和下帧的帧缓存交换
   glutSwapBuffers();
   ```

3. 单缓存与双缓存机制

   单缓存：扫描与生成点阵串行进行

   双缓存：扫描与生成点阵同时（并行）进行

**基本线画图元生成**

1. 扫描转换直线段

   1. 概念：求与直线段充分接近的像素集，并以此像素集替代原连续直线段在屏幕上显示。

   2. 约束条件：

      屏幕坐标系是整型坐标系、像素间横向和纵向距离相等、直线段为$P_0(x_0,y_0)，p_1(x_1,y_1且 x_0<x_1且均为整数)$、直线段的宽度（线宽）为1【横向或纵向像素相邻】、

      直线段的斜率$0 \leq k \leq 1$、相邻像素间坐标分量差为-1，0或1

   3. 主要算法

      1. 直线方程法

         1. 基本思想

            根据直线的几何方程确定线段路径上的像素位置。

         2. 方法

            划分区间$[x_0, x_1]$: $t_0, t_1,…, t_n,  t_{i+1}=x_{i+1}$,  其中$t_{i+1}=t_i+1,t_0 = x_0,t_n=x_1$

            计算纵坐标y：$y_i = k*t_i + b$

            取整：四舍五入，即$y_{i,r}=round(y_i)=(int)(y_i+0.5)$

         3. 主要运算：乘法+加法+取整+浮点运算

      2. 数值微分DDA算法、

         1. 方法：$y_{i+1}=k*x_{i+1}+b=k*(x_i+1)+b=y_i+k$
         2. 主要运算：加法+取整+浮点运算
         
      3. 中点算法

         1. 目标：消除浮点运算

         2. 方法

            1. 直线隐式方程

               $F(x,y)=a*x+b*y+c=0$

               可根据$F(x,y)$的大小来判断点是否在直线和点的关系：

               $F(x,y)>0$直线上方，$F(x,y)=0$直线上，$F(x,y)<0$直线下方

            2. 判断下一个像素点的坐标

               已计算出某一点的坐标$(x_i,y_{i,r})$，则可构造判别式$d=F(M)=F(x_{i+1},y_{i,r}+0.5)$，通过d的正负来判断下一点的坐标，若d<0，则选择$(x_{i+1},y_{i,r}+1)$，反之，选择$(x_{i+1},y_{i,r})$。

            3. 判断再下一个像素点的坐标

               1. 若$d \geq 0 $，则取右侧像素$(x_{i+1},y_{i,r})$，则再下一个像素$d=F(x_{i+2},y_{i,r}+0.5)=a*(x_i+2)+b*(y_{i,r}+0.5)+c=d+a$

                  此时d的增量为a

               2. 若$d<0$，则取右上侧的像素$(x_{i+1},y_{i,r}+1)$，则再下一个像素

                  $d=F(x_{i+2},y_{i,r}+1.5)=a*(x_i+2)+b*(y_{i,r}+1.5)+c=d+a+b$

                  此时d的增量为a+b

            4. d的初始值：$d_0=F(x_0+1, y_0+0.5)=F(x_0, y_0)+a+0.5*b$，因(x0, y0)在直线上，F(x0, y0)=0, 所以，$d_0 = a + 0.5*b$

            5. 增量d的递推公式

               <img src="https://pic.tim-wcx.ltd//img/20211207182412.png" alt="image-20211207182411257" style="zoom:50%;" />

            6. 注意斜率大于1和负数的情况。

2. 扫描转换圆弧

   1. 平移圆心到原点，扫描转换后再平移到原位置

   2. 圆的八对称性：由八分之一圆弧上的点可计算其它各分段弧上的点，只需要扫描转换八分之一圆弧即可

   3. 主要方法：方程法、中点算法和逼近法

   4. 主要算法

      1. 方程法

         1. 离散点：$x^2+y^2=R^2$，则$x_i,y_i=\sqrt{R^2-x_i^2}$取整得到$(x_i,y_i)$
         2. 离散角度：利用参数方程：$x=R*cos \theta.y=R*sin\theta$

      2. 中点算法

         1. 圆弧的正负划分性

            圆弧外的点：$F(x,y)>0$；圆弧上的点：$F(x,y)=0$；圆弧内的点：$F(x,y)<0$

         2. 八分圆的选择

            第一象限的八分之一圆弧中x 的变化大于 y 的变化，即圆弧上的切矢量斜率在0 ... -1间。

            因此可以使 x 从0 增加到 R/(21/2)，计算 y 的值。

         3. 確定下一像素点

            点$p(x_i, y_{i,r})$下一点所取可能点间线段的中点，$M = (x_{i+1}, y_{i,r} - 0.5)$

            当F(M)≤0时，M在圆内，说明E距离圆弧更近，取$(x_{i+1},y_{i,r})$

            当F(M)＞0时， M在圆外， 取$(x_{i+1},y_{i,r}-1)$

         4. 构造判别式

            $d_i = F(M) = F(x_i+1, y_{i,r}-0.5) = (x_i+1)^2+(y_i-0.5)^2-R^2$

            若$d \leq 0$，则再下一个像素点判定式$d_{i+1}=F(x_i+2,y_{i,r}-0.5)=d+2x_i+3$

            若$d>0$，则再下一个像素点判定式$d_{i+1}=F(x_i+2,y_{i,r}-1.5)=d+(2x_i+3)+(-2y_{i,r}+2)$

         5. d的初始值

            $d_0=F(1,R-0.5)=1.25-R$

         6. 递推公式

            <img src="https://pic.tim-wcx.ltd//img/20211207230453.png" alt="image-20211207230451615" style="zoom: 67%;" />

         7. 消除乘法运算

            <img src="https://pic.tim-wcx.ltd//img/20211207231025.png" alt="image-20211207231025042" style="zoom:67%;" />

      3. 逼近法

         1. 两种方法：正内接多边形迫近法、等面积正多边形迫近法
         2. 特点：多边形边数足够多时接近圆、误差控制边数：边越多精度越高，但计算开销大、多边形的边可用直线段的中点算法来生成

         3. 正内接多边形迫近法

            <img src="https://pic.tim-wcx.ltd//img/20211207235645.png" alt="image-20211207235645358" style="zoom:50%;" />

            ​	<img src="https://pic.tim-wcx.ltd//img/20211207235732.png" alt="image-20211207235732664" style="zoom:50%;" />

**填充图元生成**

1. 两种方法扫描转换: 

   参数－>点阵、填充（Filling） : 点阵－>点阵

2. 共享边界：左闭右开，下闭上开

3. 扫描转换多边形

   1. 两种方法：逐点判断法；扫描线算法；

   2. 多边形分类

      凸多边形(convex)：内角小于180度

      凹多边形(concave)：存在内角大于180度

      只考虑：简单多边形，即多边形边不自相交

   3. 逐点判断发，即为判断每个点和多边形的内外关系--射线法

      1. 步骤

         （1）从待判别点 v 发出射线（任意方向，一般水平方向）

         （2）求与多边形交点个数 k

         （3）k 的奇偶性决定了点与多边形的内外关系 偶数：外 奇数：内

      2. 奇异情况

         射线在边上：无数个点 ---判断射线是否与边同线

         交点为顶点：异侧：1个、同侧：0或2个

   4. 扫描线算法

      1. 目标：利用相邻像素之间的连贯性，提高算法效率

      2. 处理对象：简单多边形 非自交多边形 （边与边之间除了顶点外无其它交点）
      
      3. 步骤（对于每一条扫描线）
         1. 计算扫描线与边的交点
         2. 交点按x坐标从小到大排序
         3. 交点两两配对，填充区间
      
      4. 基本方法
      
         1. 将整个绘图窗口内扫描多边形的问题分解为一条条扫描线计算与多边形的相交区间，只要完成每条扫描线的生成就实现了多边形的扫描转换
      
         2. 一条扫描线与多边形的边有偶数个交点，每2个点形成一区间，区间内的像素位于多边形内
      
      5. 连贯性(Coherence)
      
         1. 边的连贯性(Edge Coherence)—优化交点计算
      
            某条边与当前扫描线相交，也可能与下一条扫描线相交
      
         2. 扫描线的连贯性(Scan-line Coherence) )—优化交点排序
      
            当前扫描线与各边的交点顺序与 下一条扫描线与各边的交点顺序可能相同或类似
      
         3. 区间的连贯性(Span Coherence)
      
            同一区间上的像素取同一颜色属性
      
      6. 交点
      
         1. 第一类交点：位于同一条边上的后继交点，由扫描线y＝e与多边形的交点递推计算扫描线 y＝e＋1的交点，x’＝x＋1/m
         2. 第二类交点：边与扫描线的第一个交点，边的下端点即为交点。
      
      7. 交点取整规则
      
         1. 使生成的像素全部位于多边形之内，且满足共享边界原则。
      
            （1）交点坐标不能采用“四舍五入”原则，否则会导致部分像素位于多边形之外
      
            （2）共享边界原则：左闭右开，下闭上开
      
         2. 交点横坐标x为小数，即交点落于扫描线上两个相邻像素之间
      
            （a）交点位于左边上，向右取整，(int)x + 1
      
            （b）交点位于右边上，向左取整，(int)x
      
         3. 交点横坐标x为整数，落在右、上边界的像素不予填充。落在左、下边界的像素需要填充。
      
         4. 交点是顶点，扫描线与多边形的顶点相交时，采用上开下闭及右开左闭取交点，保证交点正确配对。
      
            检查两相邻边在扫描线的哪一侧。只要检查相交的两条边的另外两个端点的Y值，两个端点Y中值大于交点Y值的个数是0，1，2，来决定取0，1，2个交点。
      
            <img src="https://pic.tim-wcx.ltd//img/20211208164405.png" alt="image-20211208154212784" style="zoom: 67%;" />
      
            分别对应交点个数为1个、1个、2个和0个。
      
         5. 水平边，不参与计算交点
      
         6. 排序，利用扫描线连贯性，采用插入排序。
      
         7. 交点两两配对与区间绘制，区间连续性，连续绘制区间上的像素。
      
      8. 算法实现
      
         1. 边的分类表ET （Edge Table）（又称新边表NET）
      
            按照边的下端点  y  坐标，对非水平边进行分类的链表
      
            下端点 y 坐标值等于i 的边属于第i类，同类中有多条边时按x从小到大排序（x也一样时按边上端点的x值）
      
            作用：避免盲目求交；计算第二类交点坐标
      
            ![image-20211208155018492](https://pic.tim-wcx.ltd//img/20211208155018.png)
      
            ET的结点信息：
                ymax: 边的上端点的 y 坐标值
      
            ​    x：边的下端点的 x 坐标
      
               deltax：边的斜率的倒数
      
               nextEdge: 下一条边的指针
      
            当扫描线 y = e + 1 == ymax，说明下一条扫描线与此边不相交。
      
         2. 活性边表AEL(Active Edge List)
      
            存放活性边的顺序链表，且按交点 x 的值从小到大排序
      
            活性边：与当前扫描线相交的边
      
            边结构定义：与ET表中结点结构相同。
      
            ```c
            typedef struct 
            {
            	int ymax;
                 float x, deltax;
                 Edge *nextEdge;
             }Edge; 
            ```
      
            AEL 的结点信息：
      
            ymax: 所交边的最大 y 值
      
            x：当前扫描线与边的交点的x坐标
      
            deltax：边的斜率的倒数
      
            nextEdge: 下一条边的指针
      
            作用：存储与当前扫描线的交点，同时快速计算下一条扫描线与多边形相交的点，且可判断边是否与下一条扫描线相交
      
            <img src="https://pic.tim-wcx.ltd//img/20211208155609.png" alt="image-20211208155609510" style="zoom:67%;" />
      
         ![image-20211208155836440](https://pic.tim-wcx.ltd//img/20211208155836.png)

**种子填充算法**

1. 区域：点阵表示的图形，像素集合

2. 表示方法：内点表示、边界表示

    1. 内点表示

        枚举出区域内部的所有像素、内部的所有像素为同一个颜色、边界像素与内部像素的颜色不同

    2. 边界表示

        枚举出边界上所有的像素、边界上的所有像素为同一颜色、内部像素与边界像素的颜色不同

    3. 区域填充算法要求区域是连通的。

3. 连通性

   （1）4连通区域：区域中任意满足相似条件两点（像素）可通过上下左右四个方向互相到达

   （2）8连通区域：区域中任意满足相似条件两点（像素）可通过上下左右和对角线八 个方向互相到达

4. 4连通区域，边界只要8连通即可，8连通区域，边界必须是4连通。

5. 算法实现：

   （1）内点表示的4连通区域
   种子s(x,y)，原色oldColor，新颜色newColor

   方法：先判断s(x, y)的颜色，若其值不等于oldColor，说明该像素位于区域外或已设置为填充色newColor 算法结束；

   否则，置像素颜色为newColor，再对其相邻的上下左右四个像素分别作为种子作上述递归处理。

6. 多边形扫描转换与区域填充方法比较
   1. 基本思想不同

     前者：顶点表示转换成点阵表示

     后者：只改变区域内填充颜色，没有改变表示方法

   2. 对边界的要求不同

     前者：扫描线与多边形边界交点个数为偶数

     后者：区域封闭，防止递归填充跨界

   3. 基本的条件不同

     前者：从边界顶点信息出发

     后者：从区域内种子点出发

7. 区域图像填充

   <img src="https://pic.tim-wcx.ltd//img/20211208162030.png" alt="image-20211208162030115" style="zoom: 80%;" />

**字符的生成**

1. 点阵字体

   存储：（压缩与非压缩）

   显示：根据编码检索点阵数据，接着写帧缓存

2. 矢量字体

   表示：笔画用曲线（参数）表示

   扫描转换：参数到点阵

   显示：1、由编码检索；2、扫描转换；3、写帧缓存

   存储：空间少

**OpenGL相关函数**

```c
//图元绘制
glBegin(type);
    glVertex*(); //指定顶点坐标1
    glVertex*(); //指定顶点坐标2
glEnd()；

//点的属性
glEnable(GL_LINE_STIPPLE);	
(1) glColor(3|4)(b|d|f|i|s|ub|ui|us)(TYPE r,TYPE g,TYPE b )
(2) glColor(3|4)(b|d|f|i|s|ub|ui|us)v(TYPE *rgb )
glPointSize（GLfloat  size) //点大小

//画线
glBegin中的参数为：GL_LINES、GL_LINE_STRIP、GL_LINE_LOOP
GL_LINES：一组直线段； GL_LINE_STRIP：折线 GL_LINE_LOOP：封闭折线

//线的属性
glLineWidth（GLfloat width) //宽度
glLineStipple(GLint factor, GLushort pattern); //线形
glEnable(GL_LINE_STIPPLE); //使用前需要激活

//填充图元函数
glRect[i|s|f|d]{v}()//矩形函数
glBegin()中的参数GL_POLYGON、GL_TRIANGLES、GL_TRIANGLE_STRIP、GL_TRIANGLE_FAN

//线框图与填充图
glPloygonMode(face，displayMode)
//face：指定前后面。可选值：GL_FRONT、GL_BACK和GL_FRONT_AND_BACK【正反面一样处理】
//displayMode：GL_FILL（填充）和GL_LINE（线框）
    
//颜色插值模式
函数：glShadeModel(mode)
Mode: GL_FLAT和GL_SMOOTH
```

图元绘制 图元类型

   | **类型**              | **说明**                 |
   | --------------------- | ------------------------ |
   | **GL_POINTS**         | **单个顶点集**           |
   | **GL_LINES**          | **多组双顶点线段**       |
   | **GL_POLYGON**        | **单个简单填充凸多边形** |
   | **GL_TRIANGLES**      | **多组独立填充三角形**   |
   | **GL_QUADS**          | **多组独立填充四边形**   |
   | **GL_LINE_STRIP**     | **不闭合折线**           |
   | **GL_LINE_LOOP**      | **闭合折线**             |
   | **GL_TRIANGLE_STRIP** | **线型连续填充三角形串** |
   | **GL_TRIANGLE_FAN**   | **扇形连续填充三角形串** |
   | **GL_QUAD_STRIP**     | **连续填充四边形串**     |

### 第四章 几何变换

**齐次坐标**

1. 定义

   定义：(x，y)点对应的齐次坐标定义为$(x_h,y_h,h),x_h=h*x,y_h=y*h,z_h=h$

   标准其次坐标：$(x,y,1)$

    h＝0表示无穷远点

**二维变换**

1. 二维变换的矩阵表示

   平移变换

   <img src="https://pic.tim-wcx.ltd//img/20211208220842.png" alt="image-20211208220841726" style="zoom:67%;" />

   旋转变换

   绕坐标原点（称为参照点，基准点）旋转角度θ （逆时针为正，顺时针为负）

   <img src="https://pic.tim-wcx.ltd//img/20211208220917.png" alt="image-20211208220917015" style="zoom:67%;" />

   放缩变换

   参照点为坐标原点

   ![image-20211208220935328](https://pic.tim-wcx.ltd//img/20211208220935.png)

   变换具有统一表示形式的优点
   1. 便于变换合成 连续变换时，可以先得到变换的矩阵
   2. 便于硬件实现 只需实现矩阵乘法

3. 变换的性质

   1. 平移和旋转变换具有可加性

      ![image-20211208221103935](https://pic.tim-wcx.ltd//img/20211208221103.png)

   2. 放缩变换具有可乘性

      ![image-20211208221124482](https://pic.tim-wcx.ltd//img/20211208221124.png)

4. 变换合成

   1. 方法：连续变换时，先计算变换矩阵，再计算坐标
   2. 优点：提高了对图形依次计算多次变换的运算效率、提供计算复杂变换的方法

5. 复合变换 矩阵乘法

   先作用的放在变换矩阵连乘式的右端，后作用的放在连乘式的左端

   $p‘=M_n*...*M_2*M_1$

6. 对称变换

   <img src="https://pic.tim-wcx.ltd//img/20211208222245.png" alt="image-20211208222245543" style="zoom:67%;" />

7. 仿射变换

   1. 二维线性变换的一般形式

      ![image-20211208222819070](https://pic.tim-wcx.ltd//img/20211208222819.png)

   2. 平移，旋转，放缩，对称和错切是特例

   3. 保持平行线间的平行关系

**三维几何变换**

1. 三维齐次坐标

   (x, y, z)点对应的齐次坐标为$(x_h,y_h,z_h,h)$，标准齐次坐标$(x,y,z,1)$

2. 右手坐标系  旋转方向，当拇指与坐标轴同向时，四指所指方向为绕该轴的正旋转方向。

3. 平移变换 

   <img src="https://pic.tim-wcx.ltd//img/20211208223811.png" alt="image-20211208223810648" style="zoom:67%;" />

4. 放缩变换

   参照点为坐标原点

   <img src="https://pic.tim-wcx.ltd//img/20211208223851.png" alt="image-20211208223851039" style="zoom: 67%;" />

5. 旋转变换

   <img src="https://pic.tim-wcx.ltd//img/20211208224145.png" alt="image-20211208224145147" style="zoom:80%;" />
   3. 绕Z轴

      <img src="https://pic.tim-wcx.ltd//img/20211208224303.png" alt="image-20211208224303864" style="zoom:67%;" />

6. 对称变换

   关于坐标平面 xy 的对称变换

   <img src="https://pic.tim-wcx.ltd//img/20211208224351.png" alt="image-20211208224351083" style="zoom:80%;" />

7. 三维几何变换的一般形式

   <img src="https://pic.tim-wcx.ltd//img/20211208224502.png" alt="image-20211208224502712" style="zoom:80%;" />

   （1）前三行和前三列对应旋转和放缩变换

   （2）第四列的前三个元素对应平移变换

   （3）第四行前三个元素对应投影变换

**图形对象的几何变换**

1. 图形对象 点，线段，多边形，圆，字符

2. 方法

   1. 先生成点集，再对其中的点进行变换 运算量大，变换前后存在点集不一致情况

   2. 对几何参数变换

      基本图形：线段，两个端点；多边形，多个顶点；圆，圆心和半径（放缩变换要求 x 和 y 放缩倍数相同）

      前提：图形对象的几何性质不随坐标变换而发生变化。这种性质称为仿射不变性。

**OpenGL几何变换函数**

```
glTranslate{fd}(tx, ty, tz) //平移函数
glRotate{fd}(theta, vx, vy, vz) //旋转函数
glScale{fd}(sx, sy, sz) //放缩函数
glLoadIdentity() //重置为单位矩阵
glMatrixMode(GL_MODELVIEW) //模型观察矩阵
glPushMatrix() //压栈
glPopMatrix() //出栈
glutInitDisplayMode (GLUT_SINGLE|GLUT_RGBA); //单缓冲
glutInitDisplayMode (GLUT_DOUBLE|GLUT_RGBA);   //双缓冲
glFinish();//强制之前的绘图函数执行，双缓冲可不调用
glutSwapBuffers(); //双缓冲必须调用
```

注意：

(1)系统几何变换矩阵只有1个

(2)坐标采用列向量表示

(3)旋转角大小用度表示，不是弧度

(4)绘图时，用系统的几何变换矩阵与顶点坐标相乘得到坐标进行绘图

(5)**只需要连续调用变换函数，先变换的函数后调用，最后绘制该图形。**

### 第五章 二维图形的显示

**二维显示流水线**

1. 基本概念
   1. 裁剪窗口(Clipping Window) ：需要显示的场景区域

     又称为世界窗口或观察窗口，简称窗口

     在世界坐标系（又称用户坐标系）内定义

   2. 视口(Viewport)：指显示设备上用来显示图形的区域

     又称视区，在设备（屏幕）坐标系内定义

   3. 裁剪(Clip)：从场景中确定位于窗口内的图形

   <img src="https://pic.tim-wcx.ltd//img/20211208231044.png" alt="image-20211208231043411" style="zoom:67%;" />

4. 裁剪窗口和视区的关系
   1. 改变视口位置可以在输出设备的不同位置上观察物体

   2. 使用多个视口可以在屏幕不同的位置观察场景的不同部分

   3. 改变窗口的尺寸达到改变视口内显示对象的多少

   4. 改变视口（或窗口）的尺寸实现图形对象放缩

      ![image-20211208231326960](https://pic.tim-wcx.ltd//img/20211208231327.png)

5. 二维显示变换

   二维图形的世界坐标系到设备坐标系的映射

   又称为窗口到视区的变换或窗口变换

6. 二维图形的显示流水线

   ![image-20211208231610251](https://pic.tim-wcx.ltd//img/20211208231610.png)

**窗口到视区的变换**

1. 步骤
   1. 在世界坐标系中，平移窗口使(xmin,  ymin)至坐标原点，变换为T (－xmin,  －ymin)
   2. 放缩使窗口的大小与视区相等，变换为S(Eu/Ex, Ev/Ey)
   3. 在设备坐标系中，平移使窗口与视区重合，变换为T (umin, vmin)

   <img src="https://pic.tim-wcx.ltd//img/20211208231827.png" alt="image-20211208231827345" style="zoom:67%;" />

2. OpenGL视区函数

   glViewport(xvmin,yvmin,vpwidth,vpheight);

3. GLU裁剪窗口函数

   gluOrtho2D(left,right,bottom,top);

   功能：将图形数据映射到屏幕的正交投影，在二维图形中可以看做设定x，y最大最小值。

   默认大小为（－1，1，－1，1）

**裁剪**

1. 定义

   判断图形元素是否落在裁剪窗口之内并找出其位于内部的部分。

2. 裁剪的次序

   （1）扫描转换后裁剪：设备坐标系，点阵表示图形

   算法简单（判断像素是否落在视区中），所有图形都要先扫描转换，速度慢。

   （2）裁剪后扫描转换：世界坐标系，参数表示图形

   最常用，节约计算时间（先对参数表示的图形裁剪），算法复杂

3. 假定条件

   矩形裁剪窗口：[xmin, ymin]－[xmax, ymax]

   被裁剪对象：线段、多边形


**直线段裁剪**

1. 待裁剪线段和窗口的关系

   (1) 完全可见：端点位于窗口内AB

   (2) 显然不可见 ：端点位于同边界外侧EF

   (3) 线段至少有一端点在窗口之外，但非显然不可见

2. 直线段直接求交算法

   1. 端点与窗口位置关系

      (1) 都在窗口内（完全可见）

      (2) 1个在窗口内，另一个在外 (有1个交点)

      (3) 2个都不在窗口内

      显然不可见？、可能相交，2个交点连接线段、可能不相交

   2. 计算交点方法

      线段与窗口的边求交点，直线与窗口边都写成参数形式，求参数值

      <img src="https://pic.tim-wcx.ltd//img/20211209185350.png" alt="image-20211209185348465" style="zoom:80%;" />

   
   3. 算法流程

   <img src="https://pic.tim-wcx.ltd//img/20211209185951.png" alt="image-20211209185951098" style="zoom:67%;" />

   4. 特点

      方法直接，易懂。不能快速判断显然不可见的线段。

3. 编码算法

   1. 算法步骤

      第一步 判别线段两端点是否都落在窗口内，如果是，则线段完全可见；否则进入第二步；

      第二步 判别线段是否为显然不可见，如果是，则裁剪结束；否则进行第三步  ；

      第三步 求线段与窗口边延长线的交点，这个交点将线段分为两段，其中一段显然不可见，丢弃。

      对余下的另一段重新进行第一步，

      第二步，第三步处理， 直至结束。

   2. 区域编码

      由窗口四条边所在直线把二维平面分成9个子区域，每个子区域赋予一个四位编码，$C_tC_bC_rC_l$，上下右左。

      <img src="https://pic.tim-wcx.ltd//img/20211209191145.png" alt="image-20211209191145865" style="zoom:80%;" />

   3. 根据顶点编码判断线段与多边形的关系

      当两个端点的编码全为0时，线段完全可见。

      当线段的两个端点的编码的逻辑“与”非零时 ，线段为显然不可见的。

   4. （1）求交前先测试与窗口哪条边所在直线有交？

      规则：判断端点编码中各位的值$C_tC_bC_rC_l$，分别对应：上、下、右和左边

      端点码值位值不同时，说明线段与对应窗口边相交

      次序：上、下、右和左边

      （2）以交点为界，丢弃外侧线段，

      以交点为新端点判断另一线段，重复算法的步骤
      
   5. 特点
   
      (1) 对完全可见和显然不可见线段的快速判别
   
      (2) 二种场合效率高
   
      ​	大裁剪窗口以及裁剪窗口特别小 (如, 光标拾取图形时，光标看作小的裁剪窗口）
   
      (3) 裁剪窗口的拓展性
   
      ​	可以延伸为凸多边形，但随着边数的增加，编码变复杂
   
4. Liang-Barsky裁剪算法

   1. 基本思想

      将二维裁剪化为一维裁剪，向X（或Y）方向投影以决定可见线段

   2.  前提

      平行于X或Y轴的线段较容易，这里不作考虑

      假设P0P1或其延长线分别与窗口左、下、右和上边（或其延长线）交于L，B，R，T

      <img src="https://pic.tim-wcx.ltd//img/20211209192142.png" alt="image-20211209192141468" style="zoom: 80%;" />

   3. 方法

      <img src="https://pic.tim-wcx.ltd//img/20211209194611.png" alt="image-20211209194610754" style="zoom: 67%;" />

      <img src="https://pic.tim-wcx.ltd//img/20211209194647.png" alt="image-20211209194646928" style="zoom: 67%;" />

      ​		（4）代入直线方程得到交点坐标。

   4. L-B算法的改进，减少求交点的次数

      1.  LL = max(xmin, min(x0, x1)) ，RR = min(xmax, max(x0, x1))

      2. <img src="https://pic.tim-wcx.ltd//img/20211209203033.png" alt="image-20211209203033630" style="zoom:80%;" />

      3. 算法

         (1)先测试 LL≤RR？不成立，不存在可见线段，退出；否则，执行（2）

         (2)线段P1P2的斜率K>0? 不是执行（3），否则执行。

         计算xT, 测试 LL ≤xT？若成立，计算xB，测试 xB ≤RR？若成立，有可见线段： xα = max(LL，xB); xβ = min(RR，xT)

         (3)K<0:计算xB,测试 LL ≤xB？若成立，计算xT，测试 xT ≤R？若成立，有可见线段： xα = max(LL ,xT); xβ = min(RR, xB)

      4. 特点
         （1）二维转化为一维（2）按需求交点，提高效率

**多边形裁剪**

1. S-H（逐边）裁剪算法基本思想

   1. 输入输出：顶点序列$V_0V_1V_2V_3V_4 ….$

   2. 定义：

      裁剪线：窗口边以及其延长线

      内侧空间与外侧空间：包含裁剪窗口的半空间为内侧空间，否则为外侧空间。

   3. 多边形与窗口裁剪线的裁剪

      化解为多边形每条边与裁剪线裁剪。

      边与裁剪线的裁剪方法：依据多边形的边SP（S是起点）与半空间（内外侧）的关系

      情况1：同在内侧，裁剪后输出P

      情况2：S 在内侧，P 在外侧，裁剪后输出交点 i

      情况3：同在外侧，裁剪后不输出

      情况4：S 在外侧， P 在内侧，裁剪后输出交点 i 和 P

      <img src="https://pic.tim-wcx.ltd//img/20211209204411.png" alt="image-20211209204410959" style="zoom: 80%;" />

   4. 算法

      将顶点序列P1P2…Pn作为输入

      依次对窗口的每条裁剪线作下列处理

      输入顶点序列

      依次顶点序列中相邻顶点构成的边PiPi+1进行裁剪处理

      输出顶点序列（下条裁剪线的输入）

   5. SH扫描顺序：左上右下

   6. 特点

      1. 裁剪算法采用流水线方式，算法简单

      2. 推广到任意凸多边形裁剪窗口

          原因是：凸多边形的边能将平面空间分成2部分，其中一部分含裁剪窗口

2. Weiler-Athenton算法

   1. 适用于裁剪窗口为任意多边形（凸、凹、带内环）的情况

   2. 内裁剪特点

      裁剪结果区域的边界由A的部分边界和B的部分边界两部分构成，并且在交点处边界发生交替，即由A的边界转至B的边界，或由B的边界转至A的边界。

   3. 交点

      出点：主多边形边界由此离开裁剪多边形区域。

      进点：主多边形边界由此进入裁剪多边形内。

**字符裁剪**

1. 基于字符串

   整个字符串完全落在窗口之内时显示，否则不显示。

   字符串的矩形包围盒测试。

   ![image-20211209205245978](https://pic.tim-wcx.ltd//img/20211209205246.png)

2. 基于字符

   一个字符完全落在窗口之内时显示，否则不显示。

   字符的矩形包围盒测试。

   ![image-20211209205327287](https://pic.tim-wcx.ltd//img/20211209205327.png)

3. 基于构成字符的最小元素 

   点阵字符：点裁剪

   矢量字符：线裁剪

   ![image-20211209205331355](https://pic.tim-wcx.ltd//img/20211209205331.png)

