# 计算机操作系统复习

### 第零章 绪论

1. 操作系统是一种规模较大、复杂性高的系统软件。

2. 操作系统做什么？

   1. 为应用程序开发提供平台 2. 为应用程序运行提供支持：提供、资源管理、驱动硬接口件。

3. 操作系统原理/OS设计与实现原理？

   功能、与硬件的接口、算法、数据结构、策略。

4. 操作系统 是如何被装入内存并开始运行的？

   BOOT->LOADER->KERNEL

5. 当你点击word的“存盘”时，你的数据是如何由内存传入磁盘？为什么你给出路径和文件名就可以得到你需要的文件内容？

   打开一个word文档是指把该文档从磁盘调入到内存并显示，文件系统。

6. 你桌面上的时钟每隔一分钟会刷新一次，怎么实现的？

   时钟中断，具体为，PIT(可编程间隔定时器) ---时钟中断---> PIC (可编程中断控制器)  ---电信号、时钟中断向量--> CPU ---> 时钟中断处理程序。

7. 对一个大规模矩阵，按行遍历快还是按列遍历更快？为什么？一个应用程序的时间性能可以通过哪些环节的改善得以提高？

   看操作系统，按行优先还是按列优先。

   降低时间复杂度，提高程序的局部性。

8. 网络数据包的发送和接收是如何实现的？

   参考链接：[Linux 数据包的接收与发送过程](https://morven.life/posts/networking-1-pkg-snd-rcv/)


> 注：CPU上下文环境是指保证程序能正常运行而需要从内存恢复到CPU中寄存器的值。
>
> 磁盘块是指$2^n$个连续扇区，扇区大小一般为512字节。

### 第一章 操作系统概述

#### 1 什么是操作系统

1、操作系统是用户与计算机硬件之间的接口

屏蔽控制硬件的细节，使应用程序的开发更简单、高效

1.2 接口形式：命令行接口、图形用户接口、系统调用

1.3 文件的存放

1.3.1 逻辑地址和物理地址

逻辑地址：簇号或扇区的逻辑编号。

物理地址：柱面号、磁头号（磁道号）、扇区号。

逻辑地址转为物理地址依赖于文件系统和设备驱动程序。

1.3.2 磁盘读文件的过程

1）用户给出文件名，提出访问文件的请求

2）文件系统通过按名访问机制获取文件的逻辑地址（磁盘块号或扇区编号）[OS完成]

3）磁盘驱动程序将逻辑地址转换为物理地址、发送磁盘操作指令 [OS完成]

2、操作系统是计算机资源的管理者

管理：处理机、内存、设备、文件、网络等。

2.1 操作系统的设计追求的主要目标

1）方便用户（最终用户和程序员）

2）提高系统性能：空间性能、时间性能、资源利用率 

#### 2 操作系统的发展

1、无操作系统 

定义：第一代计算机（1945-1955）使用电子管作为主要的电子器件，用插件板上的硬连线或穿孔卡表示程序，没有存储程序的内存，无操作系统。

2、单道批处理系统 

定义：单道批处理系统内存中只有一道作业，可以成批处理作业。克服CPU因等待人工操作造成的资源浪费问题

特点：①自动性  ②顺序性  ③单道性

优点：减少等待人工操作的时间

缺点： ①作业独占CPU ②CPU等待I/O使得CPU利用率低（相对于多道程序系统而言）    

3、多道程序系统

3.1 多道批处理系统

特点：①多道性  ②无序性 ③调度性 ④复杂性

优点：①提高CPU利用率 ②提高内存和I/O利用率 ③增加系统吞吐量

缺点： ①平均周转时间   ②缺乏交互能力

3.2 分时系统

连续的时间片轮流交替使用。

定义：①人机交互   ②共享主机  ③便于用户上机

特点：①多路性 ②独立性 ③及时性 ④交互性

优点：①提供人机交互 ②多终端共享主机

分时系统实现中的关键问题：

①及时接收：及时接收用户的命令或数据

②及时处理：及时处理用户命令。应该使所有的用户作业都直接进入内存；在很短的时间内使每个作业都得到运行。

4、微机操作系统 

5、实时操作系统 

定义：实时系统是支持实时计算的系统。实时计算可以定义成这样一类计算，既系统的正确性不仅取决于计算的逻辑结果，而且还依赖于产生结果的时间。

特点：①多路性 ②独立性 ③及时性 ④交互性 ⑤可靠性

实时任务的类型 ①周期性实时任务 ②非周期性实时任务 ③硬实时任务  ④软实时任务。

> 注：一个实际的OS可以同时具有批处理、分时和实时的特点，如Windows NT。

吞吐量是指单位时间内系统处理的作业量/任务量。

事件的开始截止时间，完成截止时间。

作业：在计算机操作系统中，作业(Job)是计算机操作员(或称为作业调度程序的程序)提供给操作系统执行任务的工作单元，一系列程序+数据的集合。

#### 3. 操作系统的特征

并发：两个或多个事件在同一时间间隔内发生。并发强调“同一时间间隔”，与并行是不同的两个概念，并行是指多个事件同时发生。

共享：系统中的资源可供内存中多个并发执行的进程共同使用。 资源共享有两种方式，即：互斥共享和同时共享。

虚拟：通过某种技术把一个物理实体变成若干逻辑上的对应物。

异步：进程以不可预知的顺序、进度运行，系统能处理随机发生的事件。

#### 4 操作系统的功能

内存管理功能、进程管理功能、设备管理功能、文件管理功能、用户接口

1、内存管理功能

内存分配;

内存保护: 确保每道用户程序都在自己的内存空间中运行，互不干扰。

地址映射;

①逻辑地址和物理地址

一个应用程序经编译后，通常会形成若干个目标程序，这些目标程序再经过链接而形成可装入程序。这些程序的地址都是从某一起始地址开始的，程序中的其它地址都是相对于起始地址计算的；由这些地址所形成的地址范围称“地址空间”，其中的地址称为“逻辑地址”。

由内存中的一系列单元所限定的地址范围称为“内存空间”，其中的地址称为“物理地址”。

②地址映射

内存扩充；虚拟内存。

内存回收：程序执行完毕或文件被关闭，系统将程序、文件占用的内存空间标记为空闲状态。

2、进程管理功能

进程控制

进程同步

进程通信

进程调度

3、设备管理功能

缓冲管理：管理各种缓冲区。

设备分配：分配用户I/O 所需要的设备。

设备处理：由设备驱动程序来实现CPU与设备控制器之间的通信。

设备独立性：应用程序与具体的物理设备无关。

虚拟设备：多个用户、多个进程课共享同一个物理设备。

4、文件管理功能

文件的按名访问

文件的存储

5、提供用户接口

命令接口

图形接口：采用图形化的操作界面。

程序接口：由一组系统调用组成。

#### 5 指令的执行

1、取指令与执行指令

1.1 取指令

在每个指令周期开始的时候，处理器从存储器中取一条指令，在典型的处理器中，程序计数器（PC）保存有下一次要取的指令的地址。除非接收到别的指示（如执行跳转指令），否则处理器在每次完成取指令后总是对PC递增，使它能够按顺序取得下一条指令。（即位于下一个高端存储器地址的指令）。

1.2 执行指令

取到的指令被放置在处理器中的指令寄存器（IR中。指令中包含确定处理器将要采取动作的位，处理器解释指令并执行要求的操作，这些操作可分为4类：

①处理器-存储器:数据在存储器和处理器之间传送；   

②处理器-I/O：数据在I/O设备和处理器之间传送；

③数据处理：算术操作或逻辑操作；

④控制：修改指令的执行顺序。

2、内部CPU寄存器

程序计数器（PC）----存指令地址

指令寄存器（IR) ----存正在执行的指令

累加器（AC)     ----临时存储体和累加操作

#### 6 小结

1. 程序执行的过程是反复取指令和执行指令的过程；

2. PC始终存有下一条待取指令的地址；

3. 指令执行的结果就是使寄存器或内存单元的值发生变化。指令执行的过程也就是存储体内容不断变化的过程。

4. 取指令和执行指令是由硬件完成的。

5. 不同硬件的体系结构支持不同的指令集合，为某种硬件平台开发的操作系统不能直接在另一种体系结构的硬件上运行。

6. 任何高级语言程序被编译成指令集合，其中的每一条指令属于机器体系结构指令集。CPU执行的最小程序单位是指令而不是高级语言程序的语句。

7. 操作系统是一组控制和管理计算机硬件和软件资源、合理地对各类作业进行调度以及方便用户的程序集合。

8. 说明逻辑地址对于程序的自动执行而言有什么意义？逻辑地址的存在使得编译器能够忽略不同操作系统和硬件的差异并且只针对统一的编址空间执行优化。

9. 以printf的执行为例说明操作系统提供了应用程序开发的方便性、操作系统屏蔽了硬件细节的作用。

   封装调用系统调用，sys_print()系统调用并返回。

10. 请简要说明操作系统为应用程序的执行做了哪些工作？

    操作系统到外存查找可执行文件

    操作系统分配内存，将程序装入内存

    为执行hello程序创建执行环境（创建新进程）

    操作系统设置CPU上下文环境，并跳到程序开始处

    程序的第一条指令执行

    程序执行与printf对应的库函数、系统调用

    执行显示驱动程序

    将像素写入存储映像区(显存）

11. 操作系统具有哪些特征？什么是并发？什么是共享？它们有什么关系？

    并发性（Concurrence）

    并行性和并发性是既相似又有区别的两个概念。并行性是指两个或多个事件在同一时刻发生，而并发性是指两个或多个在同一时间间隔内发生。在多道程序环境下，并发性是指宏观上在一段时间内有多道程序在同时执行。但在单处理机系统中，每一个时刻CPU仅能执行一道程序，故微观上，这些程序是在CPU上交互执行。

    共享性（Sharing）

    共享是指系统中的所有资源不再为一个程序所独占，而是供同时存在于系统中的多道程序所共同使用。根据资源属性不同，可有互斥共享和同时共享两种不同的共享方式。
    并发和共享关系：

    并发和共享是操作系统的两个最基本的特性，它们又是互为存在条件。一方面资源共享是以程序（进程）的并发性执行为条件的，若系统不允许程序并发执行，自然不存在资源共享问题。另一方面若系统不能对资源共享实施有效管理，则也必将影响到程序并发执行。

### 第二章 进程的描述与控制

#### 1 程序的并发运行

1 概念

在同一时间间隔内运行多个程序，一个程序还没有执行完，可以运行其它的程序，对用户而言，看到的是计算机同时运行多个程序。

程序并发执行的方式可以是多个程序分时使用多CPU或单CPU。 

2 特点

①间断性 ②多个程序共享系统资源（失去封闭性）③不可再现性 

#### 2 进程的描述

进程概念的引入是为了跟踪并描述程序的并发执行。当允许程序并发执行时，并发执行的程序可能是同一个程序在不同数据集合上的执行，也可能是不同的程序在不同数据集合上的执行，它们共享系统资源，用程序已不能方便地描述程序的并发执行，所以引入了进程的概念 。

1 进程的定义

定义1：进程是允许并发执行的程序在某个数据集合上的执行过程。

定义2：进程是由用户数据、系统数据和程序构成的实体。

2 进程的特征

并发性：多个进程实体，同存于内存中，能在一 段时间内同时运行。 

动态性：进程是进程实体的执行过程，对应了存储体的不断变化；有创建、执行、状态变化和运行终止被撤消的过程

独立性：独立运行和资源调度的基本单位。

异步性：以不同的、不可预知的速度向前推进。

结构特征：进程包括用户数据、程序、系统数据。

3 进程与程序的比较

区别 ：

①程序是静态的概念，进程是动态的概念 

②程序是永久的，进程是暂时存在的 

③程序与进程的存在实体不同 

联系 ：

①进程是程序的一次执行，进程总是对应一个特定的程序，执行程序的代码，一个进程必然对应至少一段程序。

②一个程序可以对应多个进程。同一个程序段可以在不同的数据集合上运行，因而构成若干个不同的进程。

4 程序控制块

进程控制块是进程实体的一部分，**与进程一一对应**，是操作系统中最重要的记录型数据结构，PCB中记录了操作系统所需要的用于描述进程情况及控制进程运行所需的全部信息，**只有内核程序可以直接访问**。

4.1 进程控制块中的信息

1） 进程标识符信息

 ① 外部标识符 ② 内部标识符 ③ 父进程标识符 ④子进程标识符

2）处理机状态信息

①通用寄存器 ②指令计数器 ③程序状态字PSW ④用户栈指针

3）进程调度信息
①进程状态信息 ②进程优先级 ③进程调度所需要的其他信息 ④事件

4）进程控制信息
①程序和数据的地址 ②进程同步和通信机制 ③资源清单 ④链接指针

#### 3 Linux的进程控制块

Linux PCB大小为8KB

#### 4 进程控制

1、进程的基本状态

1.1 进程的三种基本状态

 就绪状态：进程一但获得CPU就可以投入运行的状态。

 执行状态：进程获得CPU正在运行的状态。

 阻塞状态：进程由于等待资源或某个事件的发生而暂停执行的状态。 

1.2 进程状态的转换

![进程状态转换](https://img.tim-wcx.ltd/i/2022/06/08/62a007964aad7.png)

1.3 进程的组织

​	当系统中有很多进程时，可以用队列把进程控制块组织起来，形成进程队列。把具有相同状态的进程放在同一个队列中，具有不同状态的进程就可形成不同的进程队列。处于就绪状态的进程构成的进程队列称为就绪队列，处于阻塞状态的进程构成的进程队列称为阻塞队列。

1.4 链接方式

​    把具有相同状态的PCB用其中的链接字，链接成一个队列。就绪队列、执行队列和阻塞队列。

​	进程链表，循环队列

​	Pidhash表及链表 参考：[Linux内核探秘——进程（二）](https://zhuanlan.zhihu.com/p/361324735)

​	进程树

​	结构数组

2、进程的创建

2.1 引起创建进程的事件：① 用户登录 ② 作业调度③ 提供服务④ 应用请求     

2.2 进程创建 调用创建新进程的原语来创建进程，一般步骤为： ① 申请空白PCB② 为新进程分配资源③ 初始化进程控制块 ④ 将新进程插入就绪队列

3、进程阻塞

3.1 引起进程阻塞和唤醒的事件①请求系统服务，如：打印服务。②启动某种操作，如：启动I/O或启动打印机。③ 新数据尚未到达，如：一个计算进程，如果新的输入 数据还没有到达，则计算进程需要阻塞等待。

3.2 进程阻塞的简化过程①暂停进程的执行，将进程的状态改为阻塞态。②将进程插入相应的阻塞队列。③转进程调度程序，重新进行进程调度。

4、进程唤醒

4.1 进程唤醒过程 ①将进程从阻塞队列中移出 ②将进程状态由阻塞改为就绪 ③将进程插入就绪队列

5、进程的终止

5.1 引起进程终止的事件①正常结束②异常结束③外界干预

5.2 进程终止过程 ①从进程PCB中读进程状态②若进程正在执行则终止进程的执行③若进程有子孙进程则终止子孙进程*(不一定）④释放资源 ⑤将终止进程的PCB“移”出

> 注：系统引导过程：
>
> 执行BIOS程序将BOOT程序加载入内存
>
> 执行BOOT程序，从外存找到Loader程序，将其加载入内存，并执行该程序
>
> Loader程序将内核程序从外存加载入内存
>
> 内核开始执行

#### 5 操作系统内核

1、中断

中断是改变处理器执行指令顺序的一种事件。这样的事件与CPU芯片内外部 硬件电路产生的电信号相对应 。

计算机在执行程序的过程中，当出现中断时，计算机停止现行程序的运行，转向对这些中断事件的处理，处理结束后再返回到现行程序的间断处。

引入中断机制能有效提高CPU的利用率，改善系统性能。

为什么引入中断？引入中断机制后，CPU可以与其它设备并行工作，能有效提高CPU的利用率，改善系统性能，支持系统的异步性。

1.1 中断类型

内部中断和外部中断

1.2 中断响应

响应外部中断的条件:开中断

响应外部中断的时机:CPU每执行完一条指令

内部中断：随时可能产生

1.3 单重中断的执行

![单重中断的执行](https://img.tim-wcx.ltd/i/2022/06/08/62a0187fc55e7.png)

> 注：现在的计算机系统大多允许中断嵌套，在这样的系统中，保护完现场后就可以打开中断，允许响应新的中断。

1.4 如何找到中断服务程序？

不同中断源对应不同的中断向量

根据中断向量查找中断向量表

从中断向量表中读取中断服务程序的入口地址相关信息

中断服务程序的入口地址相关信息在内存中的地址=idtr中的地址+中断向量表表项的长度×中断向量的值，idtr中的地址即为中断向量表的起始地址。

1.5 关于中断OS要做的事情

初始化中断向量表

初始化中断向量表寄存器（idtr寄存器）

执行中断处理程序

1.6 需要了解的硬件：

不同中断源对应的中断向量值

可编程中断控制器接口（PIC 可编程中断控制器）

与中断相关的寄存器名称及其用途

2、时钟管理

2.1 时钟的重要性

定时测量 

编译程序

防止进程垄断CPU或其他资源(CPU时间片)

与时钟相关的软件需要时钟支持

2.2 计算机系统中的时钟

大部分PC机中有两个时钟源，分别叫做RTC和OS时钟。

RTC时钟也叫CMOS时钟，是一块时钟芯片，靠电池供电，为计算机提供计时标准，是最原始、最底层的数据。

OS时钟产生于PC主板上的定时/计数芯片，在开机时有效。

![时钟运作机制](https://img.tim-wcx.ltd/i/2022/06/08/62a01b1c9fa21.png)

2.3 操作系统的时钟机制

2.3.1 操作系统内核需要完成的定时测量功能：

1.保存当前的日期和时间；2.维持定时器。

2.3.2 如何实现？

1.操作系统依靠时钟硬件（可编程间隔定时器）2.时钟软件（时钟驱动程序）

2.3.3 OS时钟硬件（可编程间隔定时器PIT，Programmable Interval Timer)）

功能：按指定的时间间隔产生时钟中断，测量逝去的时间,并触发与时间有关的操作。

组成：OS时钟由三个元件组成：晶振、计数器、保持寄存器。

![PIT](https://img.tim-wcx.ltd/i/2022/06/08/62a01c41bf609.png)

![image-20220608114949661](https://img.tim-wcx.ltd/i/2022/06/08/62a01c5e0606f.png)

2.3.4 时钟软件（时钟驱动程序）

时钟驱动程序做的几件事：

①维护日期、时间   ②递减时间片并检查是否为零，防止进程运行超时 ③对 CPU的使用情况记帐 ④递减报警计数器

3、系统调用

系统调用是一群预先定义好的模块,它们提供一条管道让应用程序或一般用户能由此得到核心程序的服务。系统调用是核心程序与用户程序之间的接口，在类UNIX系统中，系统调用多使用C语言所提供的函数库接口。如：在程序中，使用C的函数printf(   )。

3.1 系统调用与一般函数的区别

系统调用实现例程运行在系统态（核心态）而一般函数运行在用户态。

系统调用与一般函数调用的执行过程是不同的。当系统调用执行时，当前进程被中断，由系统找相应的系统调实现例程，并在系统态下执行，执行结果返回进程。 

系统调用要进行“中断处理”比一般函数调用多了一些系统开销。

> 注：CPU内核态和用户态
>
> （1）内核态执行
>
> 内核空间是指含有一切系统核心代码的地址空间，当CPU执行系统核心代码时，称进程处于内核态执行，CPU状态为内核态。
>
> （2）用户态执行
>
> 用户空间是指用户进程所处的地址空间，当CPU执行用户空间的代码时，称该进程在用户态执行。CPU状态为用户态
>
> 0x 0000_0000 ~  0x BFFF_FFFF 用户空间 3GB
>
> 0x C000_0000 ~  0x FFFF_FFFF 内核空间 1GB

3.2 Linux系统调用的实现

system_call()

系统调用号:与系统调用一一对应的整数

系统调用表:存系统调用实现例程起始地址的数据结构 ，由系统在初始化时建立。在Linux2.4.18和Linux2.6.11中这个表是sys_call_table数组，有NR_syscalls个表项（通常是256个,在linux2.6.11中是289）：第n个表项包含系统调用号为n的服务例程的地址。

系统调用实现例程

TODO ：类似于外设的控制

int 0x80
sysenter 都可以完成从用户态到内核态的切换

![image-20220608140516278](https://img.tim-wcx.ltd/i/2022/06/08/62a03c1e84b9e.png)

3.3 系统调用的类型

进程控制类系统调用:创建、撤消进程；获得、改变进程属性；

文件操纵系统调用：创建、删除、打开、关闭、读、写文件；

设备管理系统调用：请求、释放设备；

通信用系统调用：打开、关闭连接、交换信息；

信息维护：返回系统当前日期、时间、版本号、用户数、空闲内存、磁盘空间大小。

3.4 Linux中的系统调用举例

fork创建一个新进程 clone按指定条件创建子进程 execve运行可执行文件 exit中止进程

open打开文件 creat创建新文件 close关闭文件描述字 read读文件 write写文件

 3.5 操作系统提供系统调用的优点

使编程更加容易，把用户从学习硬件设备的低级编程特性中解放出来；

提高了系统的安全性。

4、线程

线程是进程中的一个实体，**是被系统独立调度和分派的基本单位**。线程只拥有在运行中必需的资源，包括程序计数器、一组寄存器和栈，但它可以与同属一个进程的其他线程共享进程的全部资源，如：虚拟地址空间、文件。

> 注：进程作为拥有资源的基本单位。

4.1 进程与线程的关系

![进程于线程的关系](https://img.tim-wcx.ltd/i/2022/06/08/62a03d403aa20.png)

4.2 线程的三种基本状态

就绪，运行，阻塞三种状态（同进程的三种基本状态）

4.3 线程控制块TCB

线程控制块

每个线程都由一个数据结构表示，包括它的基本状态、标识以及记账信息。

线程控制块中的信息

①线程标识符信息 ②处理机状态信息 ③线程调度信息 ④线程控制信息

4.4 线程控制块的组织方式

正在执行队列、就绪队列和阻塞队列。

4.5 线程与进程的关系

 ①资源和调度 ②地址空间资源   ③通信关系 ④并发性 ⑤系统开销

TODO ：查询进程和线程之间的关系。

4.6 线程的控制

 (1) 线程的创建 (2) 线程的终止 (3) 线程的调度  (4) 线程的阻塞与唤醒  (5)线程的同步

4.7 线程实现的模型

 多对一模型、一对一模型、多对多模型

参考：

[系统线程（内核线程）和用户线程区别](https://www.jianshu.com/p/49e3e47d41f0)

[用户态线程和内核态线程有什么区别？](https://blog.csdn.net/m0_50654102/article/details/116065035)

[内核线程与用户线程区别、同步互斥的实现原理——详解](https://blog.csdn.net/weixin_46199479/article/details/123489910)

[用户线程、内核线程对应关系的三种模型](https://blog.csdn.net/weixin_42873905/article/details/115065452)

TODO：查询内核线程和用户线程之间的关系。

> 注：批处理系统可以分为单道批处理系统和多道批处理系统。批处理是指用户将一批作业提交给操作系统后就不再干预,由操作系统控制它们自动运行。
>
> 进程存在的标志是（进程控制块PCB）。

1、什么是操作系统内核﹖操作系统内核主要完成什么功能?

操作系统内核是计算机硬件的第一次扩充，内核执行OS与硬件关系密切，执行频率高的模块，常驻内存。

不同的OS内核包括的功能不同，多数OS内核包括下述功能:

支撑功能:

中断处理、时钟管理、原语操作

资源管理功能:

进程管理、存储器管理、设备管理

2、操作系统在什么时候创建进程﹖操作系统如何创建一个进程﹖举例说明操作系统创建进程的过程和进程执行的功能。(理解)

引起创建进程的事件

1、用户登录2、作业调度 3、提供服务4、应用请求。

调用创建新进程的原语来创建进程，一般步骤为:

1、申请空白PCB。2、为新进程分配资源。3、初始化进程控制块。4、将新进程插入就绪队列。

### 第三章   进程同步

1、为什么需要同步机制？

因为现代操作系统既要支持多进程（多线程）的并发执行，又要保证并发执行的程序结果是可再现的。

2、在多道程序环境下，进程之间可能存在两种关系：

1.资源共享 2.相互合作

进程同步的任务就是：

1.在资源共享的情况下：保证诸进程以互斥的方式访问临界资源—必须以互斥方  式访问的共享资源；

2.在相互合作的关系中：进程同步的主要任务是保证相互合作的诸进程在执行次序上协调，（有些教材把这种功能称做“同步”）。相互合作的进程可能同时存在资源共享的关系。

#### 1 临界资源

1、临界资源的定义

临界资源：以互斥方式访问的共享资源叫做临界资源。

临界区：每个进程中访问临界资源的那段代码称为临界区。

进入区：检查是否可以进入临界区并对临界区“加锁”的代码。

退出区：释放临界区访问权的代码。、

```c
P
｛… …
    进入区
    CS
    退出区
    … …
｝
```

2、同步机制应遵循的准则 

控制临界资源访问权的控制算法在设计上应遵循的原则 :

1.空闲让进 2. 忙则等待 3. 有限等待 4. 让权等待

#### 2 信号量机制

​	在信号量机制中，用某种类型的变量-信号量的取值来表示资源的使用状况，或某种事件是否发生，以此为基础实现进程的同步。我们将介绍整型信号量机制、记录型信号量机制、AND型信号量机制。

1、整型信号量

​	整型信号量是表示共享资源状态且只能由特殊操作改变的整型量。（其值好比信号灯的颜色）

​	信号量是一种数据结构（可以是整型数、整型数组、链表、记录型变量（结构体））。信号量的值与相应资源的使用情况有关。信号量的值仅由P、V操作改变。

​	思路：定义一个整型变量，用整型变量值标记资源使用情况：如整型量>0,说明有可用资源；整型量≤0说明资源忙，进程必须等待。对于一次只允许一个进程访问的CS，可定义一个用于互斥的整型信号量，并被初始化为1。

​	整型信号量的wait和signal操作

​	wait(s)和signal(s)是原子操作（最基本、最小的、中间不允许插入任何中断的操作。要执行就要执行完），只要信号量s≤0就不断测试，不满足让权等待。

```c
var s:integer;    	//s为整型信号量
wait(s){            //用于申请资源
    while s≤0 do no-op;
    s=s-1;
}

signal(s){          //用于释放资源
    s=s+1;
}
```

整型信号量应用举例：

用整型信号量实现进程互斥

思路：为必须互斥访问的CS定义一个互斥信号量mutex，初始值为1。然后，将CS放在wait(mutex)和signal(mutex)之间，当CS可访问时，wait(mutex)才能正常结束使进程进入临界区。

伪代码：

```c
P1:
{   …
     wait(mutex);
     counter=counter+1;
     signal(mutex);
     …
}
P2:
{   …
     wait(mutex);
     counter=counter+1;
     signal(mutex);
     …
}
```

用整型信号量实现进程协调

有p1和p2两个进程，要求p2必须在p1结束后执行，为此可设置一个信号量s，初始值置为0，同步代码如下：

```
parbegin
  begin p1; signal(s); end
  begin wait(s); p2; end
parend
```

对整型信号量机制的总结

①整型信号量的值只能由wait和signal操作改变

②==wait和signal 两个操作中对信号量的访问是不能被中断的。==（为什么？）

③原子操作可以通过关中断来实现。（为什么对临界资源的访问不简单地通过关中断来实现？）

④整型信号量机制的实例:Linux中的自旋锁SpinLock

⑤不同的资源对应不同的信号量，并不是系统中所有的资源用同一个信号量表示。

2、记录型信号量

（1）记录型信号量的数据类型 

```c
Type  semaphore=record
value:integer        //资源数量
L:list of process   //阻塞队列
end.
```

（2）记录型信号量的wait(s)和signal（s）操作

```c
procedure wait(s)
    var s:semaphore
        begin
            s.value=s.value-1;
            if s.value<0 then  
                block(s.L)
        end.

procedure signal(s)
    var s:semaphore
        begin
            s.value=s.value+1;
            if s.value<=0 then  
                wakeup(s.L)
        end.
```

（3）利用记录型信号量实现互斥

```c
var s:semaphore  
s.value=1
begin                
   repeat
       wait(s);
          critical section
       signal(s)
       remainder section
    until false;
end
```

  (4)利用记录型信号量实现“协调”的应用举例

输入进程：从外存读取数据并将数据放入内存缓冲区。

计算进程：从内存缓冲区取数据并对数据进行处理。

输入进程和计算进程共用内存缓冲区，缓冲区最多能容纳2个数据。要求：缓冲区满时，输入进程阻塞；缓冲区空时计算进程阻塞。

试采用记录型信号量机制实现输入进程与计算进程的同步。

```c
解：设置两个信号量 var empty、full:semaphore。
   初始：        empty.value=2, full.value=0
输入进程：
{
    从外存读数据；
    wait(empty).
    往缓冲区中放数据
    signal(full)
}
计算进程：
{
    wait(full)；
    从缓冲读取数据；
    signal(empty)
    处理数据；
}
```

#### 3 经典同步问题

1、生产者-消费者问题

  (1)问题描述

生产者进程生产产品，并将产品提供给消费者进程消费。为使生产者进程和消费者进程能并发执行，在它们之间设置了一个具有n个缓冲区的缓冲池，生产者进程可以将它所生产的产品放入一个缓冲区中，消费者进程可以从一个缓冲区中取得一个产品消费。任意两个进程必须以互斥的方式访问公共缓冲池。当缓冲池空时，消费者进程必须等待；当缓冲池装满产品时，生产者进程必须等待。

(2) 需要解决的问题

①==对缓冲池的互斥访问。==

②对生产者进程、消费者进程的“协调”，即：有产品时才能消费，无产品时，必须先生产后消费；有空间时才能生产，空间满时，必须先消费再生产。

 (3)信号量的设置

①一个互斥信号量，==mutex用于实现对公共缓冲池的互斥访问，初值为1。==

②两个同步信号量，分别表示可用资源数。

​     empty：表示空缓冲区数,初值为n

​     full： 表示装有产品的缓冲区数，初值为0，(一个缓冲区中放一个产品）

(4)同步程序

```c
 Producer:                               
 begin                                  
   repeat                                 
   …                                     
   produce an item in nextp;                    
   wait(empty);                             
   wait(mutex);                              
   buffer(in):=nextp;                        
   in:=(in+1)mod n
   signal(mutex);                            
   signal(full)；
 until false;  
 end       
 
 Consumer:
  begin
     repeat
     …
     wait(full);
     wait(mutex);
     nextc:=buffer(out);
     out:=(out+1)mod n;
     signal(mutex);
     signal(empty)；
     consume item in nextc;
     until false; 
     end
```

  (5)说明

①wait 和signal操作成对出现

②wait操作的顺序不能颠倒

③对具有相互合作关系的进程，提供解决问题的模型

2、习题：

TODO

某系统有同属一个进程的两个线程P和Q，共享一个数据区B，假设B区空间足够大。线程P负责周期性检测工作场所的温度，将所测结果送入数据区B。线程Q则每次从数据区B取出一个最新的检测数据进行处理。如果B区中没有检测数据，则线程Q阻塞等待。请回答下列问题：

（1）数据区B应采用什么样的数据结构？栈

（2）用记录型信号量机制实现进程P与Q之间的同步关系。（说明信号量的作用及初值）

```c
解：设置两个信号量 var empty,mutex:semaphore。
   初始：        empty.value=0,mutex.value=1
P进程：
{
	wait(mutex)
	从外存读数据；
	signal(empty)
	signal(mutex)
}
Q进程：
{
    wait(empty)
    wait(mutex)
    从缓冲读取数据；
    处理数据；
    signal(mutex)
}
```

3、 读者-写者问题

(1)问题描述

D是多个进程共享的数据区，允许多个进程同时读D区中的数据；允许一个进程往D区写数据，有一个进程在D区中执行写操作时，不能有其它任何进程在D区中执行读或写操作。

(2)信号量的设置

①全局量readcount 用于对进入共享区的读进程计数。

②rmutex用于对多个进程共享的变量readcount的互斥访问。

③wmutex用于实现读/写互斥、写/写互斥。

(3)同步程序

```
解：设置两个信号量 var rmutex,wmutex:semaphore。
   初始：        rmutex.value=1,wmutex.value=1
   变量：var readcount.
   初始：readcount=0
读进程：
{
	wait(rmutex)
	if(readcount==0)
		wait(wmutex);
	readcount++;
	signal(rmutex)
	读数据
	wait(rmutex)
	readcount--;
	if(readcount==0)
		signal(wmutex);
	signal(rmutex)
}
写进程：
{
    wait(wmutex);
    写数据
    signal(wmutex);
}
```

#### 4 管程

信号量机制的缺陷：每个访问临界资源的进程都必须自备同步操作wait(s)和signal(s)。这就使大量的同步操作分散在各个进程中，这不仅给系统的管理带来麻烦，而且还会因同步操作的使用不当而导致系统出错,因此引入了“管程”的解决方案。

 1、管程的定义

管程是描述共享资源的数据结构和在数据结构上的共享资源管理程序的集合。

2、对管程的说明

①管程是可供程序员调用的软件包，一个管程是一个由过程、变量等组成的一个集合，它们组成一个特殊的模块或软件包。进程可以在任何需要的时候调用管程中的过程，但它们不能在管程外的过程中直接访问管程内的变量。 

②每次只有一个进程调用管程执行，任一时刻管程中只能有一个活跃进程。若多个进程同时调用一个管程中的过程，只有一个进程得以进入管程，继续运行，其它进程需要等待。 

③管程是一种编程语言的构件，所以编译器知道它们很特殊，并可以采用与其他过程调用不同的方法来处理它们。典型的，当一个进程调用管程中的过程时，前几条指令将检查在管程中是否有其他的活跃进程，如果有，调用进程将挂起，直到另一个进程离开管程，如果没有，则调用进程进入管程。

如果P唤醒Q，可能有两种不同的处理方案：

P继续在管程中执行，Q等待；P等待，让Q先执行管程中的代码。

3、条件变量

为了进行并发处理，管程必须包含同步工具,例如：假设一个进程调用了管程，并且当它在管程中时必须被阻塞，直到满足某些条件。这就需要一种机制，使得该进程不仅被阻塞而且能释放这个进程，以便某些别的进程可以进入。以后当条件满足并且管程再次可用时，需要恢复该进程并允许它在阻塞点重新进入管程。管程通过使用条件变量提供同步的支持，这些条件变量包含在管程中，并且只有在管程中才能被访问。

一个管程过程，可以用在某条件变量上执行wait操作，将调用的进程阻塞并插入该条件的阻塞队列 ，也可以用在条件变量上执行signal操作，唤醒在该条件上阻塞的进程。

4、管程的应用

（1）利用管程解决生产者-消费者问题

```c
type PC=monitor
condition full, empty;
integer count;
procedure enter(item)
      begin
          if count=N then wait(full);
           enter–item;
           count=count+1;
           signal(empty) //唤醒因为队列空而阻塞的进程
       end

procedure remove(item)
      begin
          if count=0 then wait(empty);
           remove–item;
           count=count-1;
           signal(full) //唤醒因为队列满而阻塞的进程
       end
count=0;
end monitor;

Producer:
begin
     repeat
     produce an item in nextp;
     PC.enter(item);
 until false;
 end

 Consumer:
 begin
     repeat
     PC.remove(item);
     consume the item in nextc;
 until false;
 end
```

（2）利用管程解决哲学家进餐问题

问题描述

有五个哲学家围坐在一个圆桌旁，每两人之间放一只筷子，每个哲学家的行为是思考，感到饥饿，然后用餐。为了能够进餐，每个哲学家必须拿到两只筷子，并且每个人只能直接从自己的左边或右边去取筷子。

代码

```c
    type dining-philosophers=monitor
    var state:array[0..4] of (thinking,hungry,eating);
    var self:array [0..4]  of condition;
    
     procedure entry pickup(i:0..4);
        begin
            state[i]=hungry;
            test(i);
            if state[i]≠eating then self[i].wait;
      end;    

     procedure entry putdown(i:0..4);
     begin
         state[i]=thinking;
         test(i+4 mod 5);
         test(i+1 mod 5);
     end
     
     procedure test(k:0..4);
       begin
           if state[k+4 mod 5] ≠eating
               and state[k]=hungry
               and state[k+1 mod 5] ≠eating
           then begin
               state[k]=eating
               self[k].signal;
           end
        end
    
        begin
            for i:=0 to 4
               do state[i]=thinking;
        end
        
        void philosopher(int i)
       {
            while(true)
           {
                think();
                pickup(i);
                eat();
                putdown(i);
             }
        }
```

#### 5 进程间通信

![image-20220609162852242](https://img.tim-wcx.ltd/i/2022/06/09/62a1af475bba0.png)

#### 6 小结

1、实现进程互斥的基本原理是什么?

记录性信号量机制:在记录性信号机制里面有S .value，记录的是资源的信号的量，通过去验证每次这个值是否大于0，来判断是否让进程来使用此资源，但是，一旦这个值 s.value=1就允许一个进程访问该资源。从而实现了进程的互斥。这种机制用于各个进程对一个资源的共享。

AND型信号的机制:将一个进程中运行过程中的所有需要的资源，都一次性全部分配给进程。待进程使用完成后，在一并的去释放。这是好几个进程对好几个共享资源的一个实现的方法。

管程机制:利用共享数据结构抽想的表示系统的共享资源。把对该共享数据的操作定义为一组过程。进程对共享资源的操作，就是这组过程对共享数据的一个操作。

进程互斥的目的是使进程以互斥的方式访问临界资源，只要能使进程以互斥的方式进入临界区就能够保证进程对临界资源的互斥访问。所以，可以通过在临界区前加进入区代码，在临界区后面加退出区代码来实现进程的互斥。

临界区是每个进程中访问临界资源的那段代码。进入区是检查是否可以进入临界区并对临界区“加锁”的代码。退出区是释放临界区访问权的代码。

2、进程同步机制的任务是什么？

进程同步的主要任务是对多个相关进程在执行次序上进行协调,以使并发执行的诸进程之间能有效地共享资源和相互合作,从而使程序的执行具有可再现性。

3、为什么在生产者-消费者问题中wait操作的顺序不能颠倒？

如果生产者和消费者进程都先通过执行等待(互斥)申请公共缓冲池的互斥访问权，然后通过申请资源信号量申请空缓冲区或装满产品的缓冲区，当缓冲池满时，若生产者进程先申请到公共缓冲池的互斥访问权，然后申请空缓冲区，因缓冲池中没有空缓冲区，生产者进程阻塞。消费者进程因无法申请到公共缓冲池的互斥访问权，也会被阻塞.生产者进程等待消费者进程释放空缓冲区，消费者进程等待生产者进程释放公共缓冲池的互斥访问权，进程因互相等待对方释放资源而处于不能执行的僵持状态.

4、为什么对10个不同的临界资源(counter1-counter10)不能只用一个互斥信号量﹖(理解)

若用一个互斥信号量实现对多个临界资源的互斥访问，则会造成资源的浪费，一个进程申请一个资源时，会同时占用其不需要的资源，则其他进程不能访问被锁住却并没有被使用的资源。

故10个不同的临界资源不能只用一个互斥信号量。

5、三个进程P1、P2、P3互斥使用一个包含N（N > 0）个单元的缓冲区。P1每次用produce()生成一个正整数并用put()送入缓冲区某一空单元中；P2每次用getodd()从该缓冲区中取出一个奇数并用countodd()统计奇数个数；P3每次用geteven()从该缓冲区中取出一个偶数并用counteven()统计偶数个数。请用信号量机制实现这三个进程的同步与互斥活动，并说明所定义信号量的含义。要求用伪代码描述。 

采用记录型信号量来实现，伪代码如下。

```
解：设置两个信号量 var mutex,empty,odd,even:semaphore。
   初始：        mutex.value=1,empty=N,odd=0,even=0
P1进程：
{
	wait(empty)
	wait(mutex)
	num = produce()
	signal(mutex)
	if(num%2==0)
		signal(even)
	else
		signal(odd)
}
P2进程：
{
    wait(odd)
    wait(mutex)
    getodd()
    countodd()
    signal(mutex)
    signal(empty)
}
P3进程：
{
    wait(even)
    wait(mutex)
    geteven()
    counteven()
    signal(mutex)
    signal(empty)
}
```

#### 7 参考

[Linux内核自旋锁(spinlock)使用与源码分析](https://blog.csdn.net/Auris/article/details/107415378)

[操作系统第三章：进程同步和互斥](https://blog.csdn.net/weixin_42260102/article/details/100527437)

### 第四章 进程调度

调度算法是指：根据系统的资源分配策略所规定的资源分配算法 。本章介绍作业调度算法和进程调度算法。

作业调度：从后备作业队列的多个作业中选择一个作业进入内存的算法

进程调度：从多个就绪进程中选择进程并为其分配CPU的算法

中级调度：内存中不能有太多的进程，把进程从内存移到外存，当内存有足够空间时，再将合适的进程换入内存，等待进程调度。中级调度实际上就是存储器管理中的对调功能。

#### 1 调度类型和模型

根据系统的不同需求，可以采用不同的调度类型组合，从而形成以下几种调度队列模型。

(1)仅有进程调度的调度队列模型。

(2)具有作业调度和进程调度的调度队列模型。

(3)同时具有三级调度的调度队列模型。

#### 2 调度算法

1、选择调度方式和算法的若干准则

面向用户的准则

 (1) 周转时间短  (2) 响应时间快 (3) 截止时间的保证

面向系统的准则

 (1) 系统吞吐量高 (2) 处理机利用率高

2、调度算法

2.1 先来先服务调度算法

在作业调度中，FCFS就是从后备作业队列中，选择最先进入该队列的作业进行调度。

在进程调度中，FCFS  是选择最先进入就绪队列的进程，为该进程分配CPU。 

性能分析

FCFS适合长作业(进程），不利于短作业（进程），作业（进程）等待时间太长。FCFS使短作业的周转时间过长。

FCFS有利于CPU繁忙型作业（进程），如科学计算。不利于I/O繁忙型作业 （进程），如多数的事务处理。

2.2 短作业(进程)优先调度算法

短作业优先(SJF) 的调度算法。

短进程优先(SPF)的调度算法。

算法优点

与FCFS算法相比 ，短作业(进程)算法能有效降低作业（进程）的平均等待时间、平均周转时间和带权平均周转时间、 提高系统的吞吐量。

> 注：周转时间定义：
>
> 周转时间(作业周转时间)指的是从作业被提交给系统开始, 到作业完成为止的这段时间
>
> 周转时间包括四部分:
>
> 1） 作业在外存后备队列上等待作业调度的时间
>
> 2）进程在就绪队列上等待进程调度的时间
>
> 3）进程在cpu上执行的时间
>
> 4）进程等待I/O操作完成的时间
>
> 周转时间=作业完成时间−作业提交时间
>
> 平均周转时间=(作业1的周转时间+…+作业n的周转时间)/n
>
> 带权周转时间=作业周转时间作业/实际运行时间
>
> 平均带权周转时间=(作业1的带权周转时间+…+作业n的带权周转时间)/n
>
> 参考：[周转时间, 平均周转时间, 带权周转时间](https://blog.csdn.net/weixin_45867397/article/details/118110261)

算法的缺陷

对长作业不利，长作业可能长时间得不到调度。

不能保证紧迫作业的及时处理，因为该算法不考虑作业的紧迫程度。

作业长短根据用户的估计而定，故不一定能真正做到短作业优先

习题：

进程p1,p2,p3到达系统的时间分别为0ms，0ms，6ms时刻，它们需要的服务时间分别为16ms，8ms，4ms，若系统采用==短进程优先==的==非抢占式==进程调度算法，从0ms时刻开始进行进程调度，进程的调度顺序是（             ），系统的平均周转时间是（          ）。

进程调度顺序为 P2 --> p3 --> p1

平均周转时间为 (28ms + 8ms + 6ms) / 3 = 14ms

3、优先权调度算法

当使用优先权调度算法进行作业调度时，系统将从后备队列中选择优先权最高的作业调入内存。

当使用优先权调度算法进行进程调度时，系统将CPU分配给就绪队列中优先权最高的进程。

非抢占式(nonpreemptive)调度

进程一但得到处理机，则该进程便一直进行下去直到完成或由于某事件放弃处理机。

抢占式(preemptive)调度

高优先权的进程可以抢占处理机，使正在执行的低优先权进程中断执行。 在 UNIX中广泛采用抢占式。

抢占时机：基于时钟中断的抢占式优先权调度算法、立即抢占的优先权调度算法

3.1 优先权的类型

静态优先权

优先权在创建时确定，在进程的整个运行期间保持不变。决定静态优先权的依据：进程类型、进程对资源的需求、用户要求 。

静态优先权调度算法可能导致无穷阻塞(indefinite   blocking)或饥饿(starvation)问题。

动态优先权

进程创建时获得的优先权，随进程的推进而改变。

4、时间片轮转调度算法

在早期的时间片轮转算法中，系统将所有的就绪进程按先来先服务的原则，排成一个队列，每次调度时把CPU分配给队首进程，并令其执行一个时间片，当时间片用完时，调度程序终止当前进程的执行，并将它送到就绪队列的队尾。 

时间片大小的确定

系统对响应时间的要求、就绪队列中进程的数目、系统的处理能力

响应时间T=Nq

N:系统中的进程数；q: 时间片的大小。

1、（进程数一定）当系统要求的响应时间越短，时间片就越短；

2、（响应时间一定）系统允许的最大进程数越多，时间片也越短；

3、  基本命令应该在一个时间片内执行完。

性能评价

时间片轮转调度算法的性能在很大程度上依赖于时间片的大小。如果时间片很大，进程的响应时间无法保证；如果时间片很小，则进程需要经过多次上下文切换和进程调度，增加了CPU在进程切换和进程调度上的开销，影响系统的吞吐量和CPU利用率等方面的性能。

> 注：时间片的大小通常为 10~100ms。

6、多级队列调度算法

将就绪队列分成多个独立队列，根据进程的某些属性（如内存大小、进程优先权或进程类型），进程会被永久地分配到一个队列。每个队列都有自己的调度算法。不同的队列优先权不同，调度算法也可能不同。

应用举例minix的多级队列调度

![image-20220610112558612](https://img.tim-wcx.ltd/i/2022/06/10/62a2b9c97828f.png)

7、多级反馈队列调度算法

设多个优先权不同的就绪队列

允许进程在多个不同的就绪队列间移动

要考虑的问题：

就绪队列的数量

根据进程优先权确定进程应该进入哪个就绪队列的算法

用于确定进程何时转移到较高优先权队列的算法

用于确定进程何时转移到较低优先权队列的算法

#### 3 实时系统中的调度

实时系统对处理机操作或者数据流动具有严格的时限制，其进程调度对保证时间要求具有重要作用。

3.1 实现实时调度的基本条件

(1) 提供必要的调度信息

1.就绪时间。2.开始截止时间和完成截止时间 3.处理时间 4.资源要求 5.优先级

(2)系统处理能力强

1. 单处理机情况下必须满足的限制条件

   $\sum^{m}_{i=1}{\frac{C_i}{P_i}} \le 1 (1\le i \le m)$

2. N个处理机情况下必须满足的限制条件

   $\sum^{m}_{i=1}{\frac{C_i}{P_i}} \le n (1\le i \le m)$

(3)采用抢占式调度机制

          1. 基于时钟中断的抢占式优先权调度
          2. 立即抢占的优先权调度

(4)尽可能短的系统延迟

1. 对外部中断的快速响应能力
2. 快速的进程调度与切换

3.2 常用的几种实时调度算法

​    (1)最早截止时间优先EDF(Earliest Deadline First)

​    (2)最低松弛度优先LLF(Least Laxity First)

> 注：松弛度计算
>
> 松弛度(L,Laxity)用来表示一个实时任务的紧迫程度。如果一个任务的完成截止时间为T,当前时刻为Tc ,处理完该任务还需要的时间为Ts ,则松弛度计算式表示为：$L=T-	T_c - T_s$

假如一个实时系统中有两个周期性实时任务，A和B，任务A要求每20ms执行一次，执行时间为10ms；任务B只要求每50ms执行一次，执行时间25ms。
图给出了A和 B截止的时间点。

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210327193408262.png)

![在这里插入图片描述](https://img-blog.csdnimg.cn/20210327200134447.png)

![在这里插入图片描述](https://img-blog.csdnimg.cn/202103272010298.png)

> 注：在t=30时刻，A松弛度降为0，立即抢占。

参考博客：[操作系统处理机的调度问题](https://blog.csdn.net/CodePlayMe/article/details/115143674)

#### 4 小结

1、引起进程调度的原因有哪些？

(1)正在执行的进程执行完毕。这时，如果不选择新的就绪进程执行，将浪费 [处理机](http://baike.baidu.com/view/2107226.htm)资源。

(2)执行中进程自己调用阻塞原语将自己阻塞起来进入睡眠等状态。

(3)执行中进程调用了P [原语](http://baike.baidu.com/view/209669.htm)操作，从而因资源不足而被阻塞；或调用了v原语操作激活了等待资源的进程 [队列](http://baike.baidu.com/view/38959.htm)。

(4)执行中进程提出I/O请求后被阻塞。

(5)在 [分时系统](http://baike.baidu.com/view/1295402.htm)中时间片已经用完。

(6)在执行完 [系统调用](http://baike.baidu.com/view/47173.htm)等系统程序后返回用户进程时，这时可看作系统进程执行完毕，从而可调度选择一新的用户进程执行。

以上都是在 [可剥夺方式](http://baike.baidu.com/view/4043063.htm)下的引起进程调度的原因。在CPU执行方式是可剥夺时．还有

(7)就绪队列中的某进程的优先级变得高于当前执行进程的优先级，从而也将引发进程调度。

2、支持多任务的操作系统为什么需要进程调度功能？

当多个进程并发执行时候，所有的进程会共享cpu。当某一cpu上运行的进程，因为阻塞或者运行结束时而使cpu可以分配给其他进程使时，如何从众多的就绪队列中选择一个进程，将cpu分配给该进程，使系统有效运行。这是多任务操作系统必须要解决的问题。 为了更好的调度程序，设计了一些调度算法，使各个进程够更加协调的工作。

3、进程p1,p2,p3到达系统的时间分别为0ms，9ms，9ms时刻，它们需要的服务时间分别为8ms，16ms，4ms，优先权分别为100，120，140，请说明并计算当系统分别采用短进程优先的进程调度算法和基于优先权的进程调度算法时，进程的调度顺序及系统的平均周转时间。

短进程优先

P1-p3-p2

平均周转时间=(8ms+4ms+20ms)/3=32/3ms

基于优先级（非抢占式）

p1-p3-p2

平均周转时间=(8ms+4ms+20ms)/3=32/3ms

### 第六章 内存管理

#### 1 存储器的层次结构

![image-20220610121643231](https://img.tim-wcx.ltd/i/2022/06/10/62a2c5ad2187d.png)

> 注：局部性原理
>
> 程序执行的局部性原理指出：程序在执行时呈现出局部性规律，即在一较短的时间内，程序的执行仅局限于某个部分，相应地，它所访问的存储空间也局限于某个区域。关于程序执行的局部性原理有以下几个论点：
>
> 程序在执行时，除了少部分的转移和过程调用指令以外，在大多数情况下是顺序执行的。
>
> 过程调用将会使程序的执行轨迹由一部分内存区域转到另一部分内存区域。但研究表明，在大多数情况下，过程调用的深度都不超过5，这就是说，程序将会在一段时间内，局限在这些过程的范围内运行。
>
> 3.程序中存在很多循环结构，它们虽然由少数指令构成，但多次执行。
>
> 4.程序中往往包括许多对数据结构的处理，如对数组进行操作，它们往往都局限在很小的范围内。
>
> 总的来说，局部性原理表现为时间和空间的局部性：
>
> 时间局部性：如果程序中的某条指令一旦执行，则不久后该指令可能再次执行，如果某个数据结构被访问，不久以后该数据结构可能再次被访问。
>
> 空间局部性：一旦程序访问了某个单元，在不久之后，其附近的存储单元也将被访问。
>
> 具有良好局部性的程序会经常访问相同的数据集合或地址相邻的数据集合。具有良好局部性的程序比局部性差的程序能更好地利用处于高层次的储存器，减少访存时间，因此运行速度更快。

#### 2 程序的装入和链接

在多道程序环境下，程序要运行必须为之创建进程，进程执行过程中，CPU通过访问内存获取其要执行的指令。进程的执行需要操作系统将程序和数据装入内存。将一个用户的源程序变为一个可在内存中执行的程序，通常要经过编译、链接、装入 。

链接要解决的问题：将编译后的目标模块装配成一个可执行的程序。

链接的两种方式：1、静态链接 (static Linking) 2、运行时动态链接 (Run-time Dynamic Linking)

2.1 静态链接

在程序运行前，用链接程序将目标模块链接成一个完整的装入模块。 

静态链接的任务：

1）对相对地址进行修改：

2）变换外部调用符号：将每个模块中所用的外部调用符号，都变换为相对地址 

静态链接的特点：

1）存储开销大

2）程序开发不方便

3）程序运行快（相对于动态链接）

2.2 运行时动态链接

动态链接的基本思想是把程序按照模块拆分成各个相对独立部分，在程序运行时才将它们链接在一起形成一个完整的程序，而不是像静态链接一样把所有程序模块都链接成一个单独的可执行文件。

动态链接的特点：

1）节省内存和外存空间；

2）方便程序开发；

3）程序运行时的速度慢了。

3、程序的装入

3.1 绝对装入方式

编译程序事先已知程序在内存中的驻留位置，编译时产生绝对地址的目标代码，绝对装入程序按照装入模块的绝对地址将程序和数据装入内存。装入模块被装入内存后，不需对程序和数据的地址进行修改。 

